/*/////////////////////////////////////////////////////////////////////////
						  Workshop - #8 (P2)
Full Name  : Preet Bhagyesh Patel
Student ID#: 132603226
Email      : pbpatel48@myseneca.ca
Date       : 24th March 2024

Authenticity Declaration:
I have done all the coding by myself and only copied the code that my
professor provided to complete my workshops and assignments.
/////////////////////////////////////////////////////////////////////////*/

In this workshop i Learned quite a lot about smart and raw pointers this workshop was relatively easy as there was no need to make entire modules just complete parts of the modules 
Smart pointer syntax is much more easy to use as compared to raw pointers 
Raw pointers require memory allocation, memory deallocation and exception handeling manually the syntax clutter along with memory management makes it difficult to implement and is less readable Whilst smart pointers automatically manage the memory and handle exceptions. The syntax of smarl pointers is much more clear making it much more easier to read. Hers's an example from my code of this workshop highlighting the difference between the smart and raw pointer 
//         using raw pointers
		
		for (size_t i = 0; i < desc.size(); i++) {
			for (size_t j = 0; j < price.size(); j++) {
				if (desc[i].code == price[j].code) {
					Product* rawPointer = new Product(desc[i].desc, price[j].price);
					try {
						rawPointer->validate();
						priceList += rawPointer;
						delete rawPointer;
					}
					catch (const std::string& err) {
						delete rawPointer;
						throw err;
					}
				}
			}
		} 
//         using smart pointers
		unique_ptr<Product> smartPointer;
		for (size_t i = 0; i < desc.size(); i++) {
			for (size_t j = 0; j < price.size(); j++) {
				if (desc[i].code == price[j].code) {
					smartPointer = make_unique<Product>(desc[i].desc, price[j].price);
					smartPointer->validate();
					priceList += move(smartPointer);
				}
			}
		}